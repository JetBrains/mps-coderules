package jetbrains.mps.coderules.ideaplugin;

/*Generated by MPS */

import jetbrains.mps.annotations.GeneratedClass;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;

/**
 * Represents options as key-value pairs. Supports traditional levels of overrides: default/system/user/ui.
 * Every level allows any number of providers, each responsible for a specific key prefix.
 */
@GeneratedClass(node = "r:835f8ea3-a800-4588-a80b-1de6d47c2098(jetbrains.mps.coderules.ideaplugin)/8406119028231319109", model = "r:835f8ea3-a800-4588-a80b-1de6d47c2098(jetbrains.mps.coderules.ideaplugin)")
public class Config {

  /**
   * DEFAULT - options built in into code 
   * SYSTEM - options delivered with the app
   * USER - options overridden by user
   * UI - options overridden in the UI
   */
  public enum Level {
    DEFAULT(),
    SYSTEM(),
    USER(),
    UI(),
    TEST()
  }

  public interface OptionsProvider {

    Object getOption(String key);

  }

  public interface Option<T> {

    T get(Config config);

  }

  private static Config INSTANCE = null;

  public static void init() {
    if (INSTANCE == null) {
      INSTANCE = new Config(new EffectiveOptions());
    }
  }

  public static void dispose() {
    INSTANCE.clearAll();
    INSTANCE = null;
  }

  /**
   * Returns the instance to share the default (hardcoded) options.
   * 
   * @deprecated 
   */
  @Deprecated
  public static Config getInstance() {
    return INSTANCE;
  }

  /**
   * Returns a copy of this instance with the state that is not shared. All updates to either this or the
   * returned instance will not reflect in the other one. 
   */
  public Config copy() {
    return new Config(effectiveOptions);
  }

  /**
   * Creates new instance with hardcoded default options. 
   * Used from tests.
   */
  public static Config create() {
    return new Config(new EffectiveOptions());
  }

  /**
   * Used from tests.
   */
  public void reset(Level lvl) {
    this.effectiveOptions = effectiveOptions.reset(lvl);
  }

  /**
   * A prefix is defined as a string matching the following RE: "([a-zA-Z0-9]*\.)+" .
   */
  public void registerProvider(Level level, String prefix, OptionsProvider provider) {
    this.effectiveOptions = effectiveOptions.registerProvider(level, prefix, provider);
  }

  public void clearProvider(Level lvl, String prefix) {
    this.effectiveOptions = effectiveOptions.clearProvider(lvl, prefix);
  }

  public final Object getOption(String key) {
    return effectiveOptions.getOption(key);
  }

  protected void clearAll() {
    if (effectiveOptions != null) {
      effectiveOptions.clearAll();
    }
  }

  private Config(EffectiveOptions options) {
    this.effectiveOptions = options;
  }

  private static class Options {

    protected Options() {
      this.prefix2provider = new HashMap<>();
    }

    private Options(Options copyFrom) {
      this.prefix2provider = new HashMap<String, OptionsProvider>(copyFrom.prefix2provider);
    }

    protected final Object primGetOption(String key, List<String> allPrefixes) {
      OptionsProvider lookupProvider = lookupProvider(allPrefixes);
      if (lookupProvider != null) {
        Object option = lookupProvider.getOption(key);
        if (option != null) {
          return option;
        }
      }
      return null;
    }

    protected Options putProvider(String prefix, OptionsProvider provider) {
      Options newOptions = new Options(this);
      newOptions.prefix2provider.put(prefix, provider);
      return newOptions;
    }

    protected Options clearProvider(String prefix) {
      Options newOptions = new Options(this);
      newOptions.prefix2provider.remove(prefix);
      return newOptions;
    }

    protected OptionsProvider lookupProvider(List<String> prefixes) {
      for (String p : prefixes) {
        if (prefix2provider.containsKey(p)) {
          return prefix2provider.get(p);
        }
      }
      return null;
    }

    private Map<String, OptionsProvider> prefix2provider;

  }

  private static class EffectiveOptions {

    protected EffectiveOptions() {
      this.allOptions = MapSequence.fromMap(new HashMap<Config.Level, Options>());
      for (Config.Level lvl : Config.Level.values()) {
        MapSequence.fromMap(allOptions).put(lvl, new Options());
      }
    }

    private EffectiveOptions(EffectiveOptions copyFrom) {
      this.allOptions = new HashMap<Config.Level, Options>(copyFrom.allOptions);
    }

    protected Object getOption(String key) {
      List<String> allPrefixes = allPrefixes(key);
      for (int i = Config.Level.values().length - 1; i >= 0; i--) {
        Config.Level level = Config.Level.values()[i];
        Object option = check_gqj4j5_a0b0b0f33(MapSequence.fromMap(allOptions).get(level), key, allPrefixes);
        if (option != null) {
          return option;
        }
      }
      return null;
    }

    protected final EffectiveOptions reset(Config.Level startFrom) {
      EffectiveOptions newEffOptions = new EffectiveOptions(this);
      for (Config.Level lvl : Config.Level.values()) {
        if (lvl.ordinal() >= startFrom.ordinal()) {
          MapSequence.fromMap(newEffOptions.allOptions).put(lvl, new Options());
        }
      }
      return newEffOptions;
    }

    protected EffectiveOptions registerProvider(Config.Level level, String prefix, OptionsProvider provider) {
      EffectiveOptions newEffOptions = new EffectiveOptions(this);
      MapSequence.fromMap(newEffOptions.allOptions).put(level, check_gqj4j5_a0b0j33(MapSequence.fromMap(newEffOptions.allOptions).get(level), prefix, provider));
      return newEffOptions;
    }

    protected EffectiveOptions clearProvider(Config.Level level, String prefix) {
      EffectiveOptions newEffOptions = new EffectiveOptions(this);
      MapSequence.fromMap(newEffOptions.allOptions).put(level, check_gqj4j5_a0b0l33(MapSequence.fromMap(newEffOptions.allOptions).get(level), prefix));
      return newEffOptions;
    }

    protected void clearAll() {
      MapSequence.fromMap(allOptions).clear();
    }

    private List<String> allPrefixes(String key) {
      List<String> result = ListSequence.fromList(new ArrayList<String>());
      while (key.length() > 0) {
        int lastDot = key.lastIndexOf(".");
        if (lastDot < 0) {
          break;
        }
        ListSequence.fromList(result).addElement(key.substring(0, lastDot + 1));
        key = key.substring(0, lastDot);
      }
      return result;
    }

    private Map<Config.Level, Options> allOptions;
    private static Object check_gqj4j5_a0b0b0f33(Options checkedDotOperand, String key, List<String> allPrefixes) {
      if (null != checkedDotOperand) {
        return checkedDotOperand.primGetOption(key, allPrefixes);
      }
      return null;
    }
    private static Options check_gqj4j5_a0b0j33(Options checkedDotOperand, String prefix, OptionsProvider provider) {
      if (null != checkedDotOperand) {
        return checkedDotOperand.putProvider(prefix, provider);
      }
      return null;
    }
    private static Options check_gqj4j5_a0b0l33(Options checkedDotOperand, String prefix) {
      if (null != checkedDotOperand) {
        return checkedDotOperand.clearProvider(prefix);
      }
      return null;
    }
  }

  private EffectiveOptions effectiveOptions;
}
